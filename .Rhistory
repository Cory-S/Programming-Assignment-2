x <- 0:6
x
as.character(x)
class(x)
as.logical(x)
as.integer(x)
3x
function(3x)
print(x)
function(x)
3
function(3x)
function(x)
3x
x
x <- 2
x
m <- matrix(1:10, nrow = 2, ncol = 5)
m
x <- 1:4
x
y <- 5:8
y
rbind(x,y)
a <- 2
a*x*y
}
add2 <- function(x, y) {
x+y
}
add2(3, 5)
above <- function(j, n) {
use <- j > n
j[use]
}
j <- 1:20
above(j, 8)
columnmean <- function(k) {
nc <- ncol(k)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(x[, i])
}
means
}
columnmean <- function(k) {
nc <- ncol(k)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(k[, i])
}
means
}
columnmean <- function(k) {
nc <- ncol(k)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(k[i])
}
means
}
columnmean(airquality)
columnmean <- function(k) {
nc <- ncol(k)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(k[, i])
}
means
}
columnmean(airquality)
library(datasets)
data("iris")
data(iris)
iris
iris
sapply(iris, mean)
virginica <- iris(101:150, )
virg <- data.frame(iris)
virg
View(virg)
View(iris)
View(virg)
library(datasets)
data("iris")
iris_df <- data.frame(iris)
iris_df
lapply(iris_df[101:150, ], mean)
View(iris)
View(iris)
apply(iris[, 1:4], mean)
apply(iris[, 1:4] mean)
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 2, mean)
apply?
h
apply()
?apply
libary(datasets)
library(datasets)
data("mtcars")
mtcars_df <- data.frame(mtcars)
mtcars_df
View(mtcars_df)
?mtcars
sapply(mtcars, cyl, mean)
apply(mtcars, 2, mean)
mean(mtcars$mpg, mtcars$cyl)
lapply(mtcars, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
split(mtcars, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
clear()
clear
tapply(mtcars$hp, mtcars$cyl, mean)
tapply(mtcars$hp, mtcars$cyl = 8, mean)
tapply(mtcars$hp, mtcars$cyl(x = 8), mean)
tapply(mtcars$hp, mtcars(cyl = 8), mean)
tapply(mtcars$hp, mtcars(nrow = 8, cyl), mean)
tapply(mtcars$hp, mtcars[nrow = 8, cyl], mean)
tapply(mtcars$hp, mtcars[cyl = 8], mean)
abs(mean(mtcars[mtcarscyl==4,]hp) - mean(mtcars[mtcarscyl==8,]hp))
abs(mean(mtcars[mtcar$scyl==4,]hp) - mean(mtcars[mtcars$cyl==8,]hp))
abs(mean(mtcars[mtcar$scyl==4,], hp) - mean(mtcars[mtcars$cyl==8,], hp))
abs(mean(mtcars[mtcars$cyl==4,], hp) - mean(mtcars[mtcars$cyl==8,], hp))
mean(mtcars[mtcars$cyl==4,], hp)
sapply(mtcars$hp, mtcars$cyl == 4, mean)
sapply(mtcars$hp, mtcars$cyl[4], mean)
mtcars$cyl
mtcars$cyl[x=4]
mtcars$cyl[x=6]
mtcars$cyl[x=8]
mtcars$cyl[x=1:n, 4]
mtcars$cyl[], 4]
mtcars$cyl[, 4]
mtcars$cyl
for(x = 4, mtcars$cyl)
for(mtcars$cyl == 4, mtcars$cyl)
debug(ls)
ls
ls
q()
q(debug)
q
q
q
q()
q
library(datasets)
data("mtcars")
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(mtcars, cyl, mean)
split(mtcars, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
apply(mtcars, 2, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
lapply(mtcars, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
mean(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$hp, mtcars$cyl), mean)
clear
clear()
clean
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
}
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
}
cachemean <- function(x, ...) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
setwd("C:/Users/Willow Slope/Desktop/R Programming Files/ProgrammingAssignment2-master")
ls
cachematrix.r
## Completing computations on long lists can bog down R so it is sometimes helpful to
## Completing computations on long lists can bog down R so it is sometimes helpful to
## save a result of a commonly performed operation in the cache.
## This function creates a matrix object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function returns the inverse of the matrix above or looks for it in the cache
## if it has already been calculated to save resources.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
## Completing computations on long lists can bog down R so it is sometimes helpful to
## save a result of a commonly performed operation in the cache.
## This function creates a matrix object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function returns the inverse of the matrix above or looks for it in the cache
## if it has already been calculated to save resources.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
## Completing computations on long lists can bog down R so it is sometimes helpful to
## save a result of a commonly performed operation in the cache.
## This function creates a matrix object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function returns the inverse of the matrix above or looks for it in the cache
## if it has already been calculated to save resources.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
## Completing computations on long lists can bog down R so it is sometimes helpful to
## save a result of a commonly performed operation in the cache.
## This function creates a matrix object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function returns the inverse of the matrix above or looks for it in the cache
## if it has already been calculated to save resources.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
